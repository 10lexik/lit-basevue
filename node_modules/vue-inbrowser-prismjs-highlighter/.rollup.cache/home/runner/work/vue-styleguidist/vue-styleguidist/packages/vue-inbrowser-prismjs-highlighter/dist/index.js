import { __awaiter, __generator, __read, __spreadArray } from "tslib";
/* eslint-disable import/extensions */
// NOTE: this weird way of importing prism is necessary because
// prism is not a ESM ready library
import { parseComponent } from 'vue-inbrowser-compiler-utils';
import Prism from 'prismjs';
import 'prismjs/components/prism-clike.js';
import 'prismjs/components/prism-markup.js';
import 'prismjs/components/prism-javascript.js';
import 'prismjs/components/prism-typescript.js';
import 'prismjs/components/prism-jsx.js';
import 'prismjs/components/prism-tsx.js';
import 'prismjs/components/prism-css.js';
import getScript from './getScript';
Prism.manual = true;
var prismHighlight = Prism.highlight, languages = Prism.languages;
export var CONFIGURED_LANGS = ['html', 'vue-sfc', 'vsg', 'jsx', 'tsx'];
/**
 * Returns a function that returns a function will highlight the code.
 * @param errorSquigglesClassPrefix class prefix for error squiggles
 * @returns function that will return the code highlighter for the given language
 */
export default function (errorSquigglesClassPrefix) {
    return __awaiter(this, void 0, void 0, function () {
        /**
         * Return a function that will highlight the code.
         * @param lang language of the code
         * @param jsxInExamples whether to use jsx or tsx for highlighting
         */
        function getHighlighter(lang, jsxInExamples) {
            if (jsxInExamples === void 0) { jsxInExamples = false; }
            if (lang === 'vsg') {
                // render vsg format
                return function (code) {
                    if (!code) {
                        return '';
                    }
                    var scriptCode = getScript(code, jsxInExamples);
                    var scriptCodeHighlighted = prismHighlight(scriptCode, languages[jsxInExamples ? 'tsx' : 'ts'], lang);
                    if (code.length === scriptCode.length) {
                        return scriptCodeHighlighted;
                    }
                    var templateCode = code.slice(scriptCode.length);
                    var templateHighlighted = prismHighlight(templateCode, languages['html'], lang);
                    return (renderLines(scriptCodeHighlighted + templateHighlighted));
                };
            }
            else if (['html', 'vue-sfc'].includes(lang)) {
                // render vue SFC component format
                var langScheme_1 = languages.html;
                return function (code) {
                    var comp = parseComponent(code);
                    var newCode = comp.script
                        ? getCodeWithoutScript(code, comp.script, comp.scriptSetup)
                        : code;
                    var htmlHighlighted = prismHighlight(newCode, langScheme_1, 'html');
                    var highlightedScript = comp.script
                        ? htmlHighlighted.replace(getReplacedTokenRE(comp.script), prismHighlight(comp.script.content, languages[comp.script.lang || 'ts'], comp.script.lang || 'ts'))
                        : htmlHighlighted;
                    var highlightedScriptSetup = comp.scriptSetup
                        ? highlightedScript.replace(getReplacedTokenRE(comp.scriptSetup), prismHighlight(comp.scriptSetup.content, languages.ts, 'ts'))
                        : highlightedScript;
                    return renderLines(highlightedScriptSetup);
                };
            }
            else {
                // all other formats
                var langScheme_2 = languages[lang];
                return function (code, errorLoc) {
                    return renderLines(prismHighlight(code, langScheme_2, lang));
                };
            }
        }
        function addSquigglesManagement(highlight) {
            return function (code, errorLoc) { return getSquiggles(errorLoc, errorSquigglesClassPrefix) + highlight(code); };
        }
        return __generator(this, function (_a) {
            return [2 /*return*/, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return addSquigglesManagement(getHighlighter.apply(void 0, __spreadArray([], __read(args), false)));
                }];
        });
    });
}
function renderLines(code) {
    return "<span class=\"line\">".concat(code.replace(/\n/g, "</span>\n<span class='line'>"), "</span>");
}
function getSquiggles(errorLoc, errorSquigglesClassPrefix) {
    if (!errorLoc)
        return '';
    var errorWidth = 'end' in errorLoc ? errorLoc.end.column - errorLoc.start.column + 1 : 2;
    var _a = 'start' in errorLoc ? errorLoc.start : errorLoc, line = _a.line, column = _a.column;
    return ("<span class=\"".concat(errorSquigglesClassPrefix, "-wrapper\">") +
        (line > 0 ? Array(line - 1).join('\n') : '') +
        Array(column).join(' ') +
        "<span class=\"".concat(errorSquigglesClassPrefix, "\">") +
        Array(errorWidth).join(' ') +
        '</span></span>');
}
/**
 * Return SFC code without any script part.
 * Why? Because we want to highlight the script part in a separate manner.
 * This will allow us to highlight typescript code.
 * @param code SFC code
 * @param script script part of the parsed SFC
 * @param scriptSetup script part of the parsed SFC
 * @returns vue SCF code without any script part.
 * @example
 *    const code = `
 *    <template>
 *    <div>hello</div>
 *    </template>
 *    <script setup lang="ts">
 *    console.log('hello')
 *    </script>
 *    <script lang="ts">
 *    function hello() {
 *    }
 *    </script>`
 *
 *  => Returns
 *
 *     `<template>
 *     <div>hello</div>
 *     </template>
 *     <script setup lang="ts">setup</script>
 *     <script lang="ts"> </script>
 */
function getCodeWithoutScript(code, script, scriptSetup) {
    // in vue 3 the structure of the script SCF object is different
    // the start & stop are in a `loc` object.
    if (script.loc) {
        var orderedScripts = scriptSetup
            ? [scriptSetup, script].sort(function (s1, s2) { return (s1.loc.start.offset > s2.loc.start.offset ? 1 : -1); })
            : [script];
        var firstScript = orderedScripts[0];
        var nextScript = orderedScripts[1];
        if (nextScript) {
            return (code.slice(0, firstScript.loc.start.offset) +
                getSpacer(firstScript) +
                code.slice(firstScript.loc.end.offset, nextScript.loc.start.offset) +
                getSpacer(nextScript) +
                code.slice(nextScript.loc.end.offset));
        }
        else {
            return (code.slice(0, firstScript.loc.start.offset) +
                getSpacer(firstScript) +
                code.slice(firstScript.loc.end.offset));
        }
    }
    // in vue 2 the start & stop are directly attached to the script member.
    return code.slice(0, script.start) + ' ' + code.slice(script.end);
}
function getSpacer(s) {
    return s.setup ? 'setup' : ' ';
}
function getReplacedTokenRE(s) {
    return new RegExp("<span class=\"token script\"><span class=\"token language-javascript\">".concat(getSpacer(s), "</span></span>"));
}
//# sourceMappingURL=index.js.map